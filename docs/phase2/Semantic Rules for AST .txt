Group Information
Group Number: 17
Members:
1. Divyam Goel - 2017A7PS1196P
2. Nevin Thomas Kochupurakal - 2017A7PS1175P
3. Hemanth V. Alluri - 2017A7PS1170P


Semantic Rules for AST
1. <program> := <moduleDeclarations> <otherModules> <driverModule> <otherModules>1
   1. <program>.syn = new ProgramNode(<moduleDeclarations>.syn, <otherModules>.syn, <driverModule>.syn, <otherModules>1.syn)
2. <moduleDeclarations> := <moduleDeclaration> <moduleDeclarations>1
   1. <moduleDeclarations>.syn = new ModuleDeclarationNode(<moduleDeclaration>.syn, <moduleDeclarations>1.syn)
3. <moduleDeclarations> := EPSILON
   1. <moduleDeclarations>.syn = NULL
4. <moduleDeclaration> := DECLARE MODULE ID SEMICOL
   1. <moduleDeclaration>.syn = new LeafNode(ID, ID.entry)
5. <otherModules>  := <module> <otherModules>
   1. <otherModules>.syn = new OtherModuleNode(<module>.syn, <otherModules>.syn)
6. <otherModules>  := EPSILON
   1. <otherModules>.syn = NULL
7. <driverModule> := DRIVERDEF DRIVER PROGRAM DRIVERENDDEF <moduleDef>
   1. <driverModule>.syn = <moduleDef>.syn
8. <module> := DEF MODULE ID ENDDEF TAKES INPUT SQBO <input_plist> SQBC SEMICOL <ret> <moduleDef>
   1. <module>.syn = new ModuleNode(new LeafNode(ID, ID.entry), <input_plist>.syn, <ret>.syn, <moduleDef>.syn)
9. <ret> := RETURNS SQBO <output_plist> SQBC SEMICOL
   1. <ret>.syn = <output_plist>.syn
10. <ret> := EPSILON
   1. <ret>.syn = NULL
11. <input_plist> := ID COLON <dataType> <sub_input_plist>
   1. <input_plist>.syn = new InputPlistNode(new LeafNode(ID, ID.entry), <dataType>.syn, <sub_input_plist>.syn)
12. <sub_input_plist> := COMMA ID COLON <dataType> <sub_input_plist>1
   1. <sub_input_plist>.syn = new InputPlistNode(new LeafNode(ID, ID.entry), <dataType>.syn, <sub_input_plist>1.syn)
13. <sub_input_plist> := EPSILON
   1. <sub_input_plist>.syn = NULL
14. <output_plist> := ID COLON <type> <sub_output_plist>
   1. <output_plist>.syn = new OutputPlistNode(new LeafNode(ID, ID.entry), <type>.syn, <sub_output_plist>.syn)
15. <sub_output_plist> := COMMA ID COLON <type> <sub_output_plist>1
   1. <sub_output_plist>.syn = new OutputPlistNode(<type>.syn, new LeafNode(ID, ID.entry), <sub_output_plist>1.syn)
16. <sub_output_plist> := EPSILON
   1. <sub_output_plist>.syn = NULL
17. <dataType> := INTEGER
   1. <dataType>.syn = new LeafNode(TYPE, “INT”)
18. <dataType> := REAL
   1. <dataType>.syn = new LeafNode(TYPE, “REAL”)
19. <dataType> := BOOLEAN
   1. <dataType>.syn = new LeafNode(TYPE, “BOOL”)
20. <dataType> := ARRAY SQBO <dynamic_range> SQBC OF <type>
   1. <dataType>.syn = new ArrayTypeNode(<type>.syn, <dynamic_range>.syn)
21. <dynamic_range> := <index>1 RANGEOP <index>2
   1. <dynamic_range>.syn = new DynamicRangeNode(<index>1.syn, <index>2.syn)
22. <type> := INTEGER
   1. <type>.syn = new LeafNode(TYPE, “INT”)
23. <type> := REAL
   1. <type>.syn = new LeafNode(TYPE, “REAL”)
24. <type> := BOOLEAN
   1. <type>.syn = new LeafNode(TYPE, “BOOL”)
25. <moduleDef> := START <statements> END
   1. <moduleDef>.syn = <statements>.syn
26. <statements> := <statement> <statements>
   1. <statements>.syn = new StatementNode(<statement>.syn, <statements>.syn)
27. <statements> := EPSILON
   1. <statements>.syn = NULL
28. <statement> := <ioStmt>
   1. <statement>.syn = <ioStmt>.syn
29. <statement> := <simpleStmt>
   1. <statement>.syn = <simpleStmt>.syn
30. <statement> := <declareStmt>
   1. <statement>.syn = <declareStmt>.syn
31. <statement> := <conditionalStmt>
   1. <statement>.syn = <conditionalStmt>.syn
32. <statement> := <iterativeStmt>
   1. <statement>.syn = <iterativeStmt>.syn
33. <ioStmt> := GET_VALUE BO ID BC SEMICOL
   1. <ioStmt>.syn = new InputNode(new LeafNode(ID, ID.entry))
34. <ioStmt> := PRINT BO <extended_var> BC SEMICOL
   1. <ioStmt>.syn = new PrintNode(<extended_var>.syn)
35. <boolConstt> := TRUE
   1. <boolConstt>.syn = new LeafNode(BOOL, “TRUE”)
36. <boolConstt> := FALSE
   1. <boolConstt>.syn = new LeafNode(BOOL, “FALSE”)
37. <extended_var>  := <var>
   1. <extended_var>.syn = <var>.syn
38. <extended_var> := <boolConstt>
   1. <extended_var>.syn = <boolConstt>.syn
39. <var> := ID <whichId>
   1. IF (<whichId>.syn == NULL) <var>.syn = new LeafNode(ID, ID.entry)
   ELSE <var>.syn = new ArrayNode(new LeafNode(ID, ID.entry), <whichId>.syn)
40. <var> := NUM
   1. <var>.syn = new LeafNode(NUM, NUM.val)
41. <var> := RNUM
   1. <var>.syn = new LeafNode(RNUM, RNUM.val)
42. <whichId> := SQBO <index> SQBC
   1. <whichId>.syn = <index>.syn
43. <whichId> := EPSILON
   1. <whichId>.syn = NULL
44. <simpleStmt> := <assignmentStmt>
   1. <simpleStmt>.syn = <assignmentStmt>.syn
45. <simpleStmt> := <moduleReuseStmt>
   1. <simpleStmt>.syn = <moduleReuseStmt>.syn
46. <assignmentStmt> := ID <whichStmt>
   1. <assignmentStmt>.syn = new AssignStmtNode(new LeafNode(ID, ID.entry), <whichStmt>.syn)
47. <whichStmt> := <lvalueIDStmt>
   1. <whichStmt>.syn = <lvalueIDStmt>.syn
48. <whichStmt> := <lvalueARRStmt>
   1. <whichStmt>.syn = <lvalueARRStmt>.syn
49. <lvalueIDStmt> := ASSIGNOP <new_expression> SEMICOL
   1. <lvalueIDStmt>.syn = new LvalueIDNode(<new_expression>.syn)
50. <lvalueARRStmt> := SQBO <index> SQBC ASSIGNOP <new_expression> SEMICOL
   1. <lvalueARRStmt>.syn = new LvalueARRNode(<index>.syn, <new_expression>.syn)
51. <index> := NUM
   1. <index>.syn = new LeafNode(NUM, NUM.val)
52.  <index> := ID
   1. <index>.syn = new LeafNode(ID, ID.entry)
53. <moduleReuseStmt> := <optional> USE MODULE ID WITH PARAMETERS <idList> SEMICOL
   1. <moduleReuseStmt>.syn = new ModuleReuseStmtNode(<optional>.syn, <idList>.syn)
54. <optional> := SQBO <idList> SQBC ASSIGNOP 
   1. <optional>.syn = <idList>.syn
55. <optional> :=  EPSILON
   1. <optional>.syn = NULL
56. <idList> := ID <sub_idList>
   1. <idList>.syn = new IdListNode(new LeafNode(ID, ID.entry), <sub_idList>.syn)
57. <sub_idList> := COMMA ID <sub_idList>1
   1. <sub_idList>.syn = new IdListNode(new LeafNode(ID, ID.entry), <sub_idList>1.syn)
58. <sub_idList> := EPSILON
   1. <sub_idList>.inh = NULL
59. <new_expression> := <u>
   1. <new_expression>.syn = <u>.syn
60. <new_expression> := <expression>
   1. <new_expression>.syn = <expression.syn>
61. <u> := PLUS <sub_u>
   1. <u>.syn = new UNode(“PLUS”, <sub_u>.syn)
62. <u> := MINUS <sub_u>
   1. <u>.syn = new UNode(“MINUS”, <sub_u>.syn)
63. <sub_u> := BO <arithmeticExpr> BC
   1. <sub_u>.syn = <arithmeticExpr>.syn
64. <sub_u> := <var>
   1. <sub_u>.syn = <var>.syn
65. <expression> := <AnyTerm> <N7>
   1. <N7>.inh = <AnyTerm>.syn        
   2. IF (<N7>.syn == NULL) <expression>.syn = <AnyTerm>.syn ELSE <expression>.syn = <N7>.syn
66. <N7> := <logicalOp> <AnyTerm> <N7>1
   1. <N7>1.inh = <AnyTerm>.syn
   2. IF (<N7>1.syn != NULL) <N7>.syn = new N7Node(<N7>.inh, <logicalOp>.val, <N7>1.syn)         ELSE <N7>.syn = new N7Node(<N7>.inh, <logicalOp>.val, <AnyTerm>.syn)
67. <N7> := EPSILON
   1. <N7>.syn = NULL
68. <AnyTerm> := <arithmeticExpr> <N8>
   1. <N8>.inh = <arithmeticExpr>.syn
   2. IF (<N8>.syn == NULL) <AnyTerm>.syn = <arithmeticExpr>.syn ELSE <AnyTerm>.syn = <N8>.syn
69. <AnyTerm> := <boolConstt>
   1. <AnyTerm>.syn = <boolConstt>.syn
70. <N8> := <relationalOp> <arithmeticExpr>
   1. <N8>.syn = new N8Node(<N8>.inh, <relationalOp>.val, <arithmeticExpr>.syn)
71. <N8> := EPSILON
   1. <N8>.syn = NULL
72. <arithmeticExpr> := <term> <sub_arithmeticExpr>
   1. IF (<sub_arithmeticExpr>.syn == NULL) <arithmeticExpr>.syn = <term>.syn ELSE <arithmeticExpr>.syn = <sub_arithmeticExpr>.syn
   2. <sub_arithmeticExpr>.inh = <term>.syn
73. <sub_arithmeticExpr> := <op1> <term> <sub_arithmeticExpr>1
   1. <sub_arithmeticExpr>.syn = new ArithmeticExprNode(<sub_arithmeticExpr>.inh, <op1>.val, <term>.syn)
   2. <sub_arithmeticExpr>1.inh = <sub_arithmeticExpr>.syn
74. <sub_arithmeticExpr> := EPSILON
   1. <sub_arithmeticExpr>.syn = NULL
75. <term> :=  <factor> <sub_term>
   1. IF (<sub_term>.syn == NULL) <term>.syn = <factor>.syn ELSE <term>.syn = <sub_term>.syn
   2. <sub_term>.inh = <factor>.syn
76. <sub_term> := <op2> <factor> <sub_term>1
   1. <sub_term>.syn = new TermNode(<sub_term>.inh, <op2>.val, <factor>.syn)
   2. <sub_term>1.inh = <sub_term>.syn
77. <sub_term> := EPSILON
   1. <sub_term>.syn = NULL
78. <factor> := BO <expression> BC
   1. <factor>.syn  = <expression>.syn
79. <factor> := <var>
   1. <factor>.syn = <var>.syn
80. <op1> := PLUS
   1. <op1>.val = “PLUS”
81. <op1> := MINUS
   1. <op1>.val = “MINUS”
82. <op2> := MUL 
   1. <op2>.val = “MUL”
83. <op2> := DIV
   1. <op2>.val = “DIV”
84. <logicalOp> := AND
   1. <logicalOp>.val = “AND”
85. <logicalOp> := OR
   1. <logicalOp>.val = “OR”
86. <relationalOp> := LT
   1. <relationalOp>.val = “LT”
87. <relationalOp> := LE
   1. <relationalOp>.val = “LE”
88. <relationalOp> := GT
   1. <relationalOp>.val = “GT”
89. <relationalOp> := GE
   1. <relationalOp>.val = “GE”
90. <relationalOp> := EQ
   1. <relationalOp>.val = “EQ”
91. <relationalOp> := NE
   1. <relationalOp>.val = “NE”
92. <declareStmt> := DECLARE <idList> COLON <dataType> SEMICOL
   1. <declareStmt>.syn = new DeclareStmtNode(<dataType>.syn, <idList>.syn)
93. <conditionalStmt> := SWITCH BO ID BC START <caseStmt> <default> END
   1. <conditionalStmt>.syn = new CoditionalStmtNode(new LeafNode(ID, ID.entry), <caseStmt>.syn, <default>.syn)
94. <caseStmt> := CASE <value> COLON <statements> BREAK SEMICOL <nullableCaseStmt>
   1. <caseStmt>.syn = new CaseStmtNode(<value>.syn, <statements>.syn, <nullableCaseStmt>.syn)
95. <nullableCaseStmt> := CASE <value> COLON <statements> BREAK SEMICOL <nullableCaseStmt>1
   1. <nullableCaseStmt>.syn = new CaseStmtNode(<value>.syn, <statements>.syn, <nullableCaseStmt>.syn)
96. <nullableCaseStmt> := EPSILON
   1. <nullableCaseStmt>.syn = NULL
97. <value> := NUM
   1. <value> = new LeafNode(NUM, NUM.val)
98. <value> := TRUE
   1. <value> = new LeafNode(BOOL, “TRUE”)
99. <value> := FALSE
   1. <value> = new LeafNode(BOOL, “FALSE”)
100. <default> := DEFAULT COLON <statements> BREAK SEMICOL
   1. <default>.syn = <statements>.syn
101. <default> :=  EPSILON
   1. <default>.syn = NULL
102. <iterativeStmt> := FOR BO ID IN <range> BC START <statements> END
   1. <iterativeStmt>.syn = new ForIterativeStmtNode(new LeafNode(ID, ID.entry), <range>.syn, <statements>.syn)
103. <iterativeStmt> := WHILE BO <expression> BC START <statements> END
   1. <iterativeStmt>.syn = new WhileIterativeStmtNode(<expression>.syn, <statements>.syn)
104. <range> := NUM1 RANGEOP NUM2
   1. <range>.syn = new RangeNode(new LeafNode(NUM1, NUM1.val), new LeafNode(NUM2, NUM2.val))
